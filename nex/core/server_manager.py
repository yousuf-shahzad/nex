"""
Core server management functionality
"""
import os
import shutil
import subprocess
import platform
from typing import Dict, List, Any, Optional
import signal
import sys
import logging

from nex.downloaders import get_downloader_for_type
from nex.config.properties import ServerProperties
from nex.utils.java_utils import find_java_executable
from nex.utils.logger import setup_logger

logger = setup_logger(__name__)

class ServerError(Exception):
    """Base exception for server-related errors."""
    pass

class ServerJarNotFoundError(ServerError):
    """Raised when no server JAR file is found."""
    pass

class JavaNotFoundError(ServerError):
    """Raised when Java executable is not found."""
    pass

class ServerManager:
    def __init__(self, server_dir: str):
        """Initialize a server manager for the specified directory."""
        self.server_dir = os.path.abspath(server_dir)
        logger.info(f"Initializing ServerManager for directory: {self.server_dir}")
        
        # Create the directory if it doesn't exist
        if not os.path.exists(self.server_dir):
            logger.info(f"Creating server directory: {self.server_dir}")
            os.makedirs(self.server_dir)
    
    def download_server(self, version: str, server_type: str) -> str:
        """Download a server JAR of the specified type and version."""
        logger.info(f"Downloading {server_type} server version {version}")
        downloader = get_downloader_for_type(server_type)
        
        # Handle "latest" version request
        if version.lower() == "latest":
            logger.info("Fetching latest version")
            versions = downloader.get_versions()
            if not versions:
                raise ValueError(f"No versions available for {server_type}")
            version = versions[0]  # Assume the first version is the latest
            logger.info(f"Latest version found: {version}")
        
        # Download the server JAR
        try:
            jar_path = downloader.download(version, self.server_dir)
            logger.info(f"Server JAR downloaded to: {jar_path}")
            return jar_path
        except Exception as e:
            logger.error(f"Failed to download server: {str(e)}")
            raise ServerError(f"Failed to download server: {str(e)}")
    
    def setup_server(self, properties: Dict[str, Any]) -> None:
        """Set up the server with the specified properties."""
        logger.info("Setting up server with provided properties")
        
        # Find the server JAR file
        jar_files = [f for f in os.listdir(self.server_dir) if f.endswith('.jar')]
        if not jar_files:
            raise ServerJarNotFoundError("No server JAR file found. Please download a server first.")
        
        # Create eula.txt (accepting the EULA)
        eula_path = os.path.join(self.server_dir, "eula.txt")
        logger.info("Creating EULA file")
        with open(eula_path, "w") as f:
            f.write("# Generated by Nex\n")
            f.write("eula=true\n")
        
        # Create server.properties with user-specified settings
        server_props = ServerProperties()
        for key, value in properties.items():
            server_props.set_property(key, value)
        
        # Write the properties to file
        props_path = os.path.join(self.server_dir, "server.properties")
        logger.info(f"Writing server properties to: {props_path}")
        server_props.save(props_path)
    
    def list_versions(self, server_type: str) -> List[str]:
        """List available versions for a server type."""
        logger.info(f"Listing available versions for {server_type}")
        downloader = get_downloader_for_type(server_type)
        return downloader.get_versions()
    
    def run_server(self, ram: str, java_path: Optional[str] = None, nogui: bool = False) -> None:
        """Run the Minecraft server with the specified RAM allocation."""
        logger.info(f"Starting server with {ram} RAM allocation")
        
        # Find the server JAR file
        jar_files = [f for f in os.listdir(self.server_dir) if f.endswith('.jar')]
        if not jar_files:
            raise ServerJarNotFoundError("No server JAR file found. Please download a server first.")
        
        # Sort by modification time, newest first
        jar_files.sort(key=lambda f: os.path.getmtime(os.path.join(self.server_dir, f)), 
                      reverse=True)
        server_jar = jar_files[0]
        logger.info(f"Using server JAR: {server_jar}")
        
        # Find Java executable
        java_exec = java_path or find_java_executable()
        if not java_exec:
            raise JavaNotFoundError("Java not found. Please install Java or specify the path.")
        logger.info(f"Using Java executable: {java_exec}")
        
        # Prepare the command
        cmd = [
            java_exec,
            f"-Xmx{ram}",
            f"-Xms{ram}",
            "-jar",
            server_jar
        ]
        
        if nogui:
            cmd.append("nogui")
        
        logger.info(f"Starting server with command: {' '.join(cmd)}")
        
        # Initialize process to None
        process = None

        # Handle Ctrl+C gracefully by passing it through to the server
        def signal_handler(sig, frame):
            logger.info("Received stop signal, stopping server gracefully...")
            if process:
                # Send "stop" command to the server stdin
                process.stdin.write(b"stop\n")
                process.stdin.flush()
            else:
                sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Run the server
        try:
            process = subprocess.Popen(
                cmd,
                cwd=self.server_dir,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            # Print server output in real-time
            for line in process.stdout:
                logger.info(line.strip())
                
            process.wait()
        except Exception as e:
            logger.error(f"Failed to run server: {str(e)}")
            raise ServerError(f"Failed to run server: {str(e)}") 