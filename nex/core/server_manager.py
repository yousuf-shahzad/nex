"""
Core server management functionality
"""
import os
import shutil
import subprocess
import platform
from typing import Dict, List, Any, Optional
import signal
import sys

from nex.downloaders import get_downloader_for_type
from nex.config.properties import ServerProperties
from nex.utils.java_utils import find_java_executable


class ServerManager:
    def __init__(self, server_dir: str):
        """Initialize a server manager for the specified directory."""
        self.server_dir = os.path.abspath(server_dir)
        
        # Create the directory if it doesn't exist
        if not os.path.exists(self.server_dir):
            os.makedirs(self.server_dir)
    
    def download_server(self, version: str, server_type: str) -> str:
        """Download a server JAR of the specified type and version."""
        downloader = get_downloader_for_type(server_type)
        
        # Handle "latest" version request
        if version.lower() == "latest":
            versions = downloader.get_versions()
            if not versions:
                raise ValueError(f"No versions available for {server_type}")
            version = versions[0]  # Assume the first version is the latest
        
        # Download the server JAR
        jar_path = downloader.download(version, self.server_dir)
        return jar_path
    
    def setup_server(self, properties: Dict[str, Any]) -> None:
        """Set up the server with the specified properties."""
        # Find the server JAR file
        jar_files = [f for f in os.listdir(self.server_dir) if f.endswith('.jar')]
        if not jar_files:
            raise ValueError("No server JAR file found. Please download a server first.")
        
        # Create eula.txt (accepting the EULA)
        eula_path = os.path.join(self.server_dir, "eula.txt")
        with open(eula_path, "w") as f:
            f.write("# Generated by Nex\n")
            f.write("eula=true\n")
        
        # Create server.properties with user-specified settings
        server_props = ServerProperties()
        for key, value in properties.items():
            server_props.set_property(key, value)
        
        # Write the properties to file
        server_props.save(os.path.join(self.server_dir, "server.properties"))
    
    def list_versions(self, server_type: str) -> List[str]:
        """List available versions for a server type."""
        downloader = get_downloader_for_type(server_type)
        return downloader.get_versions()
    
    def run_server(self, ram: str, java_path: Optional[str] = None, nogui: bool = False) -> None:
        """Run the Minecraft server with the specified RAM allocation."""
        # Find the server JAR file
        jar_files = [f for f in os.listdir(self.server_dir) if f.endswith('.jar')]
        if not jar_files:
            raise ValueError("No server JAR file found. Please download a server first.")
        
        # Sort by modification time, newest first
        jar_files.sort(key=lambda f: os.path.getmtime(os.path.join(self.server_dir, f)), 
                      reverse=True)
        server_jar = jar_files[0]
        
        # Find Java executable
        java_exec = java_path or find_java_executable()
        if not java_exec:
            raise RuntimeError("Java not found. Please install Java or specify the path.")
        
        # Prepare the command
        cmd = [
            java_exec,
            f"-Xmx{ram}",
            f"-Xms{ram}",
            "-jar",
            server_jar
        ]
        
        if nogui:
            cmd.append("nogui")
        
        print(f"Starting server with command: {' '.join(cmd)}")
        
        # Handle Ctrl+C gracefully by passing it through to the server
        def signal_handler(sig, frame):
            print("Stopping the server gracefully...")
            if process:
                # Send "stop" command to the server stdin
                process.stdin.write(b"stop\n")
                process.stdin.flush()
            else:
                sys.exit(0)
        
        signal.signal(signal.SIGINT, signal_handler)
        
        # Run the server
        try:
            process = subprocess.Popen(
                cmd,
                cwd=self.server_dir,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                bufsize=1
            )
            
            # Print server output in real-time
            for line in process.stdout:
                print(line, end='')
                
            process.wait()
        except Exception as e:
            raise RuntimeError(f"Failed to run server: {str(e)}") 