import os
import re
from typing import Dict, Any, Optional, Union

# Default values for common properties
DEFAULT_PROPERTIES = {
    "gamemode": "survival",
    "difficulty": "easy",
    "pvp": True,
    "online-mode": True,
    "max-players": 20,
    "motd": "A Minecraft Server",
    "enable-command-block": False,
    "spawn-protection": 16,
    "view-distance": 10,
    "spawn-npcs": True,
    "spawn-animals": True,
    "spawn-monsters": True,
    "generate-structures": True,
    "level-seed": ""
}

# Property validators
def validate_property(key: str, value: Any) -> tuple[bool, str]:
    """Validate a server property value."""
    
    # Define validation rules for specific properties
    if key == "gamemode":
        valid_modes = ["survival", "creative", "adventure", "spectator"]
        if str(value).lower() not in valid_modes:
            return False, f"Invalid gamemode. Must be one of: {', '.join(valid_modes)}"
    
    elif key == "difficulty":
        valid_difficulties = ["peaceful", "easy", "normal", "hard"]
        if str(value).lower() not in valid_difficulties:
            return False, f"Invalid difficulty. Must be one of: {', '.join(valid_difficulties)}"
    
    elif key == "pvp" or key == "online-mode" or key.startswith("enable-") or key.startswith("spawn-"):
        # Boolean properties
        if not isinstance(value, bool) and str(value).lower() not in ["true", "false"]:
            return False, f"{key} must be true or false"
    
    elif key == "max-players" or key == "view-distance" or key == "spawn-protection":
        # Integer properties
        try:
            int_val = int(value)
            if int_val < 0:
                return False, f"{key} must be a positive integer"
        except ValueError:
            return False, f"{key} must be an integer"
    
    return True, ""


class ServerProperties:
    """Class to manage Minecraft server.properties."""
    
    def __init__(self, file_path: Optional[str] = None):
        """Initialize with optional existing properties file."""
        self.properties = DEFAULT_PROPERTIES.copy()
        
        if file_path and os.path.exists(file_path):
            self.load(file_path)
    
    def load(self, file_path: str) -> None:
        """Load properties from a file."""
        try:
            with open(file_path, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        key_value = line.split('=', 1)
                        if len(key_value) == 2:
                            key, value = key_value
                            # Convert value types
                            if value.lower() == 'true':
                                value = True
                            elif value.lower() == 'false':
                                value = False
                            elif value.isdigit():
                                value = int(value)
                            self.properties[key] = value
        except Exception as e:
            raise IOError(f"Failed to load properties: {str(e)}")
    
    def save(self, file_path: str) -> None:
        """Save properties to a file."""
        try:
            with open(file_path, 'w') as f:
                f.write("#Minecraft server properties\n")
                f.write(f"#Generated by Nex\n")
                
                for key, value in self.properties.items():
                    # Convert Python types to appropriate strings
                    if isinstance(value, bool):
                        value_str = str(value).lower()
                    else:
                        value_str = str(value)
                    
                    f.write(f"{key}={value_str}\n")
        except Exception as e:
            raise IOError(f"Failed to save properties: {str(e)}")
    
    def get_property(self, key: str, default: Any = None) -> Any:
        """Get a property value."""
        return self.properties.get(key, default)
    
    def set_property(self, key: str, value: Any) -> None:
        """Set a property value with validation."""
        valid, message = validate_property(key, value)
        if not valid:
            raise ValueError(message)
        
        self.properties[key] = value
    
    def get_all(self) -> Dict[str, Any]:
        """Get all properties."""
        return self.properties.copy()